From 30fc437af394b722f5204b31f992063b24680988 Mon Sep 17 00:00:00 2001
From: WJXXBSH <********@outlook.com>
Date: Mon, 7 Sep 2020 11:13:13 +0800
Subject: [PATCH] system_extras_su_AddonSU

Change-Id: I572ba7a0aca8ff8debc6630ee52394f4d37a471d
---
 su/Android.mk             |  32 +-
 su/MODULE_LICENSE_APACHE2 |   0
 su/NOTICE                 | 190 ----------
 su/daemon.c               | 711 ++++++++++++++++++++++++++++++++++++++
 su/pts.c                  | 369 ++++++++++++++++++++
 su/pts.h                  | 116 +++++++
 su/su.c                   | 592 +++++++++++++++++++++++++++++++
 su/su.cpp                 | 144 --------
 su/su.h                   | 121 +++++++
 su/superuser.rc           |  12 +
 su/utils.c                |  53 +++
 su/utils.h                |  23 ++
 12 files changed, 2023 insertions(+), 340 deletions(-)
 delete mode 100644 su/MODULE_LICENSE_APACHE2
 delete mode 100644 su/NOTICE
 create mode 100644 su/daemon.c
 create mode 100644 su/pts.c
 create mode 100644 su/pts.h
 create mode 100644 su/su.c
 delete mode 100644 su/su.cpp
 create mode 100644 su/su.h
 create mode 100644 su/superuser.rc
 create mode 100644 su/utils.c
 create mode 100644 su/utils.h

diff --git a/su/Android.mk b/su/Android.mk
index e3da4f21..4833d33a 100644
--- a/su/Android.mk
+++ b/su/Android.mk
@@ -1,12 +1,32 @@
-LOCAL_PATH:= $(call my-dir)
-include $(CLEAR_VARS)
-
-LOCAL_CFLAGS := -Wall -Werror
+# Root AOSP source makefile
+# su is built here, and
+LOCAL_PATH := $(call my-dir)

-LOCAL_SRC_FILES:= su.cpp
+include $(CLEAR_VARS)

-LOCAL_MODULE:= su
+LOCAL_MODULE := su
+LOCAL_MODULE_TAGS := optional
+LOCAL_SHARED_LIBRARIES := \
+    libbinder \
+    libcutils \
+    liblog \
+    libutils \

+LOCAL_SRC_FILES := su.c daemon.c utils.c pts.c
 LOCAL_MODULE_PATH := $(TARGET_OUT_OPTIONAL_EXECUTABLES)

+LOCAL_INIT_RC := superuser.rc
+
 include $(BUILD_EXECUTABLE)
+
+SYMLINKS := $(addprefix $(TARGET_OUT)/bin/,su)
+$(SYMLINKS):
+	@echo "Symlink: $@ -> /system/xbin/su"
+	@mkdir -p $(dir $@)
+	@rm -rf $@
+	$(hide) ln -sf ../xbin/su $@
+
+# We need this so that the installed files could be picked up based on the
+# local module name
+ALL_MODULES.$(LOCAL_MODULE).INSTALLED := \
+    $(ALL_MODULES.$(LOCAL_MODULE).INSTALLED) $(SYMLINKS)
diff --git a/su/MODULE_LICENSE_APACHE2 b/su/MODULE_LICENSE_APACHE2
deleted file mode 100644
index e69de29b..00000000
diff --git a/su/NOTICE b/su/NOTICE
deleted file mode 100644
index c5b1efa7..00000000
--- a/su/NOTICE
+++ /dev/null
@@ -1,190 +0,0 @@
-
-   Copyright (c) 2005-2008, The Android Open Source Project
-
-   Licensed under the Apache License, Version 2.0 (the "License");
-   you may not use this file except in compliance with the License.
-
-   Unless required by applicable law or agreed to in writing, software
-   distributed under the License is distributed on an "AS IS" BASIS,
-   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-   See the License for the specific language governing permissions and
-   limitations under the License.
-
-
-                                 Apache License
-                           Version 2.0, January 2004
-                        http://www.apache.org/licenses/
-
-   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
-
-   1. Definitions.
-
-      "License" shall mean the terms and conditions for use, reproduction,
-      and distribution as defined by Sections 1 through 9 of this document.
-
-      "Licensor" shall mean the copyright owner or entity authorized by
-      the copyright owner that is granting the License.
-
-      "Legal Entity" shall mean the union of the acting entity and all
-      other entities that control, are controlled by, or are under common
-      control with that entity. For the purposes of this definition,
-      "control" means (i) the power, direct or indirect, to cause the
-      direction or management of such entity, whether by contract or
-      otherwise, or (ii) ownership of fifty percent (50%) or more of the
-      outstanding shares, or (iii) beneficial ownership of such entity.
-
-      "You" (or "Your") shall mean an individual or Legal Entity
-      exercising permissions granted by this License.
-
-      "Source" form shall mean the preferred form for making modifications,
-      including but not limited to software source code, documentation
-      source, and configuration files.
-
-      "Object" form shall mean any form resulting from mechanical
-      transformation or translation of a Source form, including but
-      not limited to compiled object code, generated documentation,
-      and conversions to other media types.
-
-      "Work" shall mean the work of authorship, whether in Source or
-      Object form, made available under the License, as indicated by a
-      copyright notice that is included in or attached to the work
-      (an example is provided in the Appendix below).
-
-      "Derivative Works" shall mean any work, whether in Source or Object
-      form, that is based on (or derived from) the Work and for which the
-      editorial revisions, annotations, elaborations, or other modifications
-      represent, as a whole, an original work of authorship. For the purposes
-      of this License, Derivative Works shall not include works that remain
-      separable from, or merely link (or bind by name) to the interfaces of,
-      the Work and Derivative Works thereof.
-
-      "Contribution" shall mean any work of authorship, including
-      the original version of the Work and any modifications or additions
-      to that Work or Derivative Works thereof, that is intentionally
-      submitted to Licensor for inclusion in the Work by the copyright owner
-      or by an individual or Legal Entity authorized to submit on behalf of
-      the copyright owner. For the purposes of this definition, "submitted"
-      means any form of electronic, verbal, or written communication sent
-      to the Licensor or its representatives, including but not limited to
-      communication on electronic mailing lists, source code control systems,
-      and issue tracking systems that are managed by, or on behalf of, the
-      Licensor for the purpose of discussing and improving the Work, but
-      excluding communication that is conspicuously marked or otherwise
-      designated in writing by the copyright owner as "Not a Contribution."
-
-      "Contributor" shall mean Licensor and any individual or Legal Entity
-      on behalf of whom a Contribution has been received by Licensor and
-      subsequently incorporated within the Work.
-
-   2. Grant of Copyright License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      copyright license to reproduce, prepare Derivative Works of,
-      publicly display, publicly perform, sublicense, and distribute the
-      Work and such Derivative Works in Source or Object form.
-
-   3. Grant of Patent License. Subject to the terms and conditions of
-      this License, each Contributor hereby grants to You a perpetual,
-      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
-      (except as stated in this section) patent license to make, have made,
-      use, offer to sell, sell, import, and otherwise transfer the Work,
-      where such license applies only to those patent claims licensable
-      by such Contributor that are necessarily infringed by their
-      Contribution(s) alone or by combination of their Contribution(s)
-      with the Work to which such Contribution(s) was submitted. If You
-      institute patent litigation against any entity (including a
-      cross-claim or counterclaim in a lawsuit) alleging that the Work
-      or a Contribution incorporated within the Work constitutes direct
-      or contributory patent infringement, then any patent licenses
-      granted to You under this License for that Work shall terminate
-      as of the date such litigation is filed.
-
-   4. Redistribution. You may reproduce and distribute copies of the
-      Work or Derivative Works thereof in any medium, with or without
-      modifications, and in Source or Object form, provided that You
-      meet the following conditions:
-
-      (a) You must give any other recipients of the Work or
-          Derivative Works a copy of this License; and
-
-      (b) You must cause any modified files to carry prominent notices
-          stating that You changed the files; and
-
-      (c) You must retain, in the Source form of any Derivative Works
-          that You distribute, all copyright, patent, trademark, and
-          attribution notices from the Source form of the Work,
-          excluding those notices that do not pertain to any part of
-          the Derivative Works; and
-
-      (d) If the Work includes a "NOTICE" text file as part of its
-          distribution, then any Derivative Works that You distribute must
-          include a readable copy of the attribution notices contained
-          within such NOTICE file, excluding those notices that do not
-          pertain to any part of the Derivative Works, in at least one
-          of the following places: within a NOTICE text file distributed
-          as part of the Derivative Works; within the Source form or
-          documentation, if provided along with the Derivative Works; or,
-          within a display generated by the Derivative Works, if and
-          wherever such third-party notices normally appear. The contents
-          of the NOTICE file are for informational purposes only and
-          do not modify the License. You may add Your own attribution
-          notices within Derivative Works that You distribute, alongside
-          or as an addendum to the NOTICE text from the Work, provided
-          that such additional attribution notices cannot be construed
-          as modifying the License.
-
-      You may add Your own copyright statement to Your modifications and
-      may provide additional or different license terms and conditions
-      for use, reproduction, or distribution of Your modifications, or
-      for any such Derivative Works as a whole, provided Your use,
-      reproduction, and distribution of the Work otherwise complies with
-      the conditions stated in this License.
-
-   5. Submission of Contributions. Unless You explicitly state otherwise,
-      any Contribution intentionally submitted for inclusion in the Work
-      by You to the Licensor shall be under the terms and conditions of
-      this License, without any additional terms or conditions.
-      Notwithstanding the above, nothing herein shall supersede or modify
-      the terms of any separate license agreement you may have executed
-      with Licensor regarding such Contributions.
-
-   6. Trademarks. This License does not grant permission to use the trade
-      names, trademarks, service marks, or product names of the Licensor,
-      except as required for reasonable and customary use in describing the
-      origin of the Work and reproducing the content of the NOTICE file.
-
-   7. Disclaimer of Warranty. Unless required by applicable law or
-      agreed to in writing, Licensor provides the Work (and each
-      Contributor provides its Contributions) on an "AS IS" BASIS,
-      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
-      implied, including, without limitation, any warranties or conditions
-      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
-      PARTICULAR PURPOSE. You are solely responsible for determining the
-      appropriateness of using or redistributing the Work and assume any
-      risks associated with Your exercise of permissions under this License.
-
-   8. Limitation of Liability. In no event and under no legal theory,
-      whether in tort (including negligence), contract, or otherwise,
-      unless required by applicable law (such as deliberate and grossly
-      negligent acts) or agreed to in writing, shall any Contributor be
-      liable to You for damages, including any direct, indirect, special,
-      incidental, or consequential damages of any character arising as a
-      result of this License or out of the use or inability to use the
-      Work (including but not limited to damages for loss of goodwill,
-      work stoppage, computer failure or malfunction, or any and all
-      other commercial damages or losses), even if such Contributor
-      has been advised of the possibility of such damages.
-
-   9. Accepting Warranty or Additional Liability. While redistributing
-      the Work or Derivative Works thereof, You may choose to offer,
-      and charge a fee for, acceptance of support, warranty, indemnity,
-      or other liability obligations and/or rights consistent with this
-      License. However, in accepting such obligations, You may act only
-      on Your own behalf and on Your sole responsibility, not on behalf
-      of any other Contributor, and only if You agree to indemnify,
-      defend, and hold each Contributor harmless for any liability
-      incurred by, or claims asserted against, such Contributor by reason
-      of your accepting any such warranty or additional liability.
-
-   END OF TERMS AND CONDITIONS
-
diff --git a/su/daemon.c b/su/daemon.c
new file mode 100644
index 00000000..0a405683
--- /dev/null
+++ b/su/daemon.c
@@ -0,0 +1,711 @@
+/*
+** Copyright 2010, Adam Shanks (@ChainsDD)
+** Copyright 2008, Zinx Verituse (@zinxv)
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#include <stdlib.h>
+#include <sys/socket.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/un.h>
+#include <sys/wait.h>
+#include <unistd.h>
+
+#include <log/log.h>
+
+#include "pts.h"
+#include "su.h"
+#include "utils.h"
+
+int is_daemon = 0;
+int daemon_from_uid = 0;
+int daemon_from_pid = 0;
+
+// Constants for the atty bitfield
+#define ATTY_IN 1
+#define ATTY_OUT 2
+#define ATTY_ERR 4
+
+/*
+ * Receive a file descriptor from a Unix socket.
+ * Contributed by @mkasick
+ *
+ * Returns the file descriptor on success, or -1 if a file
+ * descriptor was not actually included in the message
+ *
+ * On error the function terminates by calling exit(-1)
+ */
+static int recv_fd(int sockfd)
+{
+    // Need to receive data from the message, otherwise don't care about it.
+    char iovbuf;
+
+    struct iovec iov = {
+        .iov_base = &iovbuf,
+        .iov_len = 1,
+    };
+
+    char cmsgbuf[CMSG_SPACE(sizeof(int))];
+
+    struct msghdr msg = {
+        .msg_iov = &iov,
+        .msg_iovlen = 1,
+        .msg_control = cmsgbuf,
+        .msg_controllen = sizeof(cmsgbuf),
+    };
+
+    if (recvmsg(sockfd, &msg, MSG_WAITALL) != 1)
+    {
+        goto error;
+    }
+
+    // Was a control message actually sent?
+    switch (msg.msg_controllen)
+    {
+    case 0:
+        // No, so the file descriptor was closed and won't be used.
+        return -1;
+    case sizeof(cmsgbuf):
+        // Yes, grab the file descriptor from it.
+        break;
+    default:
+        goto error;
+    }
+
+    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
+
+    if (cmsg == NULL ||
+        cmsg->cmsg_len != CMSG_LEN(sizeof(int)) ||
+        cmsg->cmsg_level != SOL_SOCKET ||
+        cmsg->cmsg_type != SCM_RIGHTS)
+    {
+        goto error;
+    }
+
+    return *(int *)CMSG_DATA(cmsg);
+
+error:
+    ALOGE("unable to read fd");
+    exit(-1);
+}
+
+/*
+ * Send a file descriptor through a Unix socket.
+ * Contributed by @mkasick
+ *
+ * On error the function terminates by calling exit(-1)
+ *
+ * fd may be -1, in which case the dummy data is sent,
+ * but no control message with the FD is sent.
+ */
+static void send_fd(int sockfd, int fd)
+{
+    // Need to send some data in the message, this will do.
+    struct iovec iov = {
+        .iov_base = "",
+        .iov_len = 1,
+    };
+
+    struct msghdr msg = {
+        .msg_iov = &iov,
+        .msg_iovlen = 1,
+    };
+
+    char cmsgbuf[CMSG_SPACE(sizeof(int))];
+
+    if (fd != -1)
+    {
+        // Is the file descriptor actually open?
+        if (fcntl(fd, F_GETFD) == -1)
+        {
+            if (errno != EBADF)
+            {
+                goto error;
+            }
+            // It's closed, don't send a control message or sendmsg will EBADF.
+        }
+        else
+        {
+            // It's open, send the file descriptor in a control message.
+            msg.msg_control = cmsgbuf;
+            msg.msg_controllen = sizeof(cmsgbuf);
+
+            struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
+            if (!cmsg)
+            {
+                goto error;
+            }
+
+            cmsg->cmsg_len = CMSG_LEN(sizeof(int));
+            cmsg->cmsg_level = SOL_SOCKET;
+            cmsg->cmsg_type = SCM_RIGHTS;
+
+            *(int *)CMSG_DATA(cmsg) = fd;
+        }
+    }
+
+    if (sendmsg(sockfd, &msg, 0) != 1)
+    {
+        goto error;
+    }
+
+    return;
+
+error:
+    PLOGE("unable to send fd");
+    exit(-1);
+}
+
+static int read_int(int fd)
+{
+    int val;
+    int len = read(fd, &val, sizeof(int));
+    if (len != sizeof(int))
+    {
+        ALOGE("unable to read int: %d", len);
+        exit(-1);
+    }
+    return val;
+}
+
+static void write_int(int fd, int val)
+{
+    int written = write(fd, &val, sizeof(int));
+    if (written != sizeof(int))
+    {
+        PLOGE("unable to write int");
+        exit(-1);
+    }
+}
+
+static char *read_string(int fd)
+{
+    int len = read_int(fd);
+    if (len > PATH_MAX || len < 0)
+    {
+        ALOGE("invalid string length %d", len);
+        exit(-1);
+    }
+    char *val = malloc(sizeof(char) * (len + 1));
+    if (val == NULL)
+    {
+        ALOGE("unable to malloc string");
+        exit(-1);
+    }
+    val[len] = '\0';
+    int amount = read(fd, val, len);
+    if (amount != len)
+    {
+        ALOGE("unable to read string");
+        exit(-1);
+    }
+    return val;
+}
+
+static void write_string(int fd, char *val)
+{
+    int len = strlen(val);
+    write_int(fd, len);
+    int written = write(fd, val, len);
+    if (written != len)
+    {
+        PLOGE("unable to write string");
+        exit(-1);
+    }
+}
+
+static int run_daemon_child(int infd, int outfd, int errfd, int argc, char **argv)
+{
+    if (-1 == dup2(outfd, STDOUT_FILENO))
+    {
+        PLOGE("dup2 child outfd");
+        exit(-1);
+    }
+
+    if (-1 == dup2(errfd, STDERR_FILENO))
+    {
+        PLOGE("dup2 child errfd");
+        exit(-1);
+    }
+
+    if (-1 == dup2(infd, STDIN_FILENO))
+    {
+        PLOGE("dup2 child infd");
+        exit(-1);
+    }
+
+    close(infd);
+    close(outfd);
+    close(errfd);
+
+    return su_main(argc, argv, 0);
+}
+
+static int daemon_accept(int fd)
+{
+    is_daemon = 1;
+    int pid = read_int(fd);
+    int child_result;
+    ALOGD("remote pid: %d", pid);
+    char *pts_slave = read_string(fd);
+    ALOGD("remote pts_slave: %s", pts_slave);
+    daemon_from_pid = read_int(fd);
+    ALOGV("remote req pid: %d", daemon_from_pid);
+
+    struct ucred credentials;
+    socklen_t ucred_length = sizeof(struct ucred);
+    /* fill in the user data structure */
+    if (getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &credentials, &ucred_length))
+    {
+        ALOGE("could obtain credentials from unix domain socket");
+        exit(-1);
+    }
+
+    daemon_from_uid = credentials.uid;
+
+    // The the FDs for each of the streams
+    int infd = recv_fd(fd);
+    int outfd = recv_fd(fd);
+    int errfd = recv_fd(fd);
+
+    int argc = read_int(fd);
+    if (argc < 0 || argc > 512)
+    {
+        ALOGE("unable to allocate args: %d", argc);
+        exit(-1);
+    }
+    ALOGV("remote args: %d", argc);
+    char **argv = (char **)malloc(sizeof(char *) * (argc + 1));
+    if (!argv)
+    {
+        ALOGE("unable to allocate memory\n");
+        exit(-1);
+    }
+    argv[argc] = NULL;
+    int i;
+    for (i = 0; i < argc; i++)
+    {
+        argv[i] = read_string(fd);
+    }
+
+    // ack
+    write_int(fd, 1);
+
+    // Fork the child process. The fork has to happen before calling
+    // setsid() and opening the pseudo-terminal so that the parent
+    // is not affected
+    int child = fork();
+    if (child < 0)
+    {
+        for (i = 0; i < argc; i++)
+        {
+            free(argv[i]);
+        }
+        free(argv);
+
+        // fork failed, send a return code and bail out
+        PLOGE("unable to fork");
+        write(fd, &child, sizeof(int));
+        close(fd);
+        return child;
+    }
+
+    if (child != 0)
+    {
+        for (i = 0; i < argc; i++)
+        {
+            free(argv[i]);
+        }
+        free(argv);
+
+        // In parent, wait for the child to exit, and send the exit code
+        // across the wire.
+        int code, status;
+
+        free(pts_slave);
+
+        ALOGD("waiting for child exit");
+        if (waitpid(child, &status, 0) > 0)
+        {
+            code = WEXITSTATUS(status);
+        }
+        else
+        {
+            code = -1;
+        }
+
+        // Is the file descriptor actually open?
+        if (fcntl(fd, F_GETFD) == -1)
+        {
+            if (errno != EBADF)
+            {
+                return code;
+            }
+        }
+
+        // Pass the return code back to the client
+        ALOGD("sending code");
+        if (send(fd, &code, sizeof(int), MSG_NOSIGNAL) != sizeof(int))
+        {
+            PLOGE("unable to write exit code");
+        }
+
+        close(fd);
+        ALOGD("child exited");
+        return code;
+    }
+
+    // We are in the child now
+    // Close the unix socket file descriptor
+    close(fd);
+
+    // Become session leader
+    if (setsid() == (pid_t)-1)
+    {
+        PLOGE("setsid");
+    }
+
+    int ptsfd;
+    if (pts_slave[0])
+    {
+        // Opening the TTY has to occur after the
+        // fork() and setsid() so that it becomes
+        // our controlling TTY and not the daemon's
+        ptsfd = open(pts_slave, O_RDWR);
+        if (ptsfd == -1)
+        {
+            PLOGE("open(pts_slave) daemon");
+            exit(-1);
+        }
+
+        struct stat st;
+        if (fstat(ptsfd, &st))
+        {
+            PLOGE("failed to stat pts_slave");
+            exit(-1);
+        }
+
+        if (st.st_uid != credentials.uid)
+        {
+            PLOGE("caller doesn't own proposed PTY");
+            exit(-1);
+        }
+
+        if (!S_ISCHR(st.st_mode))
+        {
+            PLOGE("proposed PTY isn't a chardev");
+            exit(-1);
+        }
+
+        if (infd < 0)
+        {
+            ALOGD("daemon: stdin using PTY");
+            infd = ptsfd;
+        }
+        if (outfd < 0)
+        {
+            ALOGD("daemon: stdout using PTY");
+            outfd = ptsfd;
+        }
+        if (errfd < 0)
+        {
+            ALOGD("daemon: stderr using PTY");
+            errfd = ptsfd;
+        }
+    }
+    else
+    {
+        // TODO: Check system property, if PTYs are disabled,
+        // made infd the CTTY using:
+        // ioctl(infd, TIOCSCTTY, 1);
+    }
+    free(pts_slave);
+
+    child_result = run_daemon_child(infd, outfd, errfd, argc, argv);
+    for (i = 0; i < argc; i++)
+    {
+        free(argv[i]);
+    }
+    free(argv);
+    return child_result;
+}
+
+int run_daemon()
+{
+    if (getuid() != 0 || getgid() != 0)
+    {
+        PLOGE("daemon requires root. uid/gid not root");
+        return -1;
+    }
+
+    int fd;
+    struct sockaddr_un sun;
+
+    fd = socket(AF_LOCAL, SOCK_STREAM, 0);
+    if (fd < 0)
+    {
+        PLOGE("socket");
+        return -1;
+    }
+    if (fcntl(fd, F_SETFD, FD_CLOEXEC))
+    {
+        PLOGE("fcntl FD_CLOEXEC");
+        goto err;
+    }
+
+    memset(&sun, 0, sizeof(sun));
+    sun.sun_family = AF_LOCAL;
+    sprintf(sun.sun_path, "%s/su-daemon", DAEMON_SOCKET_PATH);
+
+    /*
+     * Delete the socket to protect from situations when
+     * something bad occured previously and the kernel reused pid from that process.
+     * Small probability, isn't it.
+     */
+    unlink(sun.sun_path);
+    unlink(DAEMON_SOCKET_PATH);
+
+    int previous_umask = umask(027);
+    mkdir(DAEMON_SOCKET_PATH, 0711);
+
+    if (bind(fd, (struct sockaddr *)&sun, sizeof(sun)) < 0)
+    {
+        PLOGE("daemon bind");
+        goto err;
+    }
+
+    chmod(DAEMON_SOCKET_PATH, 0711);
+    chmod(sun.sun_path, 0666);
+
+    umask(previous_umask);
+
+    if (listen(fd, 10) < 0)
+    {
+        PLOGE("daemon listen");
+        goto err;
+    }
+
+    int client;
+    while ((client = accept(fd, NULL, NULL)) > 0)
+    {
+        if (fork_zero_fucks() == 0)
+        {
+            close(fd);
+            return daemon_accept(client);
+        }
+        else
+        {
+            close(client);
+        }
+    }
+
+    ALOGE("daemon exiting");
+err:
+    close(fd);
+    return -1;
+}
+
+// List of signals which cause process termination
+static int quit_signals[] = {SIGALRM, SIGHUP, SIGPIPE, SIGQUIT, SIGTERM, SIGINT, 0};
+
+static void sighandler(__attribute__((unused)) int sig)
+{
+    restore_stdin();
+
+    // Assume we'll only be called before death
+    // See note before sigaction() in set_stdin_raw()
+    //
+    // Now, close all standard I/O to cause the pumps
+    // to exit so we can continue and retrieve the exit
+    // code
+    close(STDIN_FILENO);
+    close(STDOUT_FILENO);
+    close(STDERR_FILENO);
+
+    // Put back all the default handlers
+    struct sigaction act;
+    int i;
+
+    memset(&act, '\0', sizeof(act));
+    act.sa_handler = SIG_DFL;
+    for (i = 0; quit_signals[i]; i++)
+    {
+        if (sigaction(quit_signals[i], &act, NULL) < 0)
+        {
+            PLOGE("Error removing signal handler");
+            continue;
+        }
+    }
+}
+
+/**
+ * Setup signal handlers trap signals which should result in program termination
+ * so that we can restore the terminal to its normal state and retrieve the
+ * return code.
+ */
+static void setup_sighandlers(void)
+{
+    struct sigaction act;
+    int i;
+
+    // Install the termination handlers
+    // Note: we're assuming that none of these signal handlers are already trapped.
+    // If they are, we'll need to modify this code to save the previous handler and
+    // call it after we restore stdin to its previous state.
+    memset(&act, '\0', sizeof(act));
+    act.sa_handler = &sighandler;
+    for (i = 0; quit_signals[i]; i++)
+    {
+        if (sigaction(quit_signals[i], &act, NULL) < 0)
+        {
+            PLOGE("Error installing signal handler");
+            continue;
+        }
+    }
+}
+
+int connect_daemon(int argc, char *argv[], int ppid)
+{
+    int ptmx = -1;
+    char pts_slave[PATH_MAX];
+
+    struct sockaddr_un sun;
+
+    // Open a socket to the daemon
+    int socketfd = socket(AF_LOCAL, SOCK_STREAM, 0);
+    if (socketfd < 0)
+    {
+        PLOGE("socket");
+        exit(-1);
+    }
+    if (fcntl(socketfd, F_SETFD, FD_CLOEXEC))
+    {
+        PLOGE("fcntl FD_CLOEXEC");
+        exit(-1);
+    }
+
+    memset(&sun, 0, sizeof(sun));
+    sun.sun_family = AF_LOCAL;
+    sprintf(sun.sun_path, "%s/su-daemon", DAEMON_SOCKET_PATH);
+
+    if (0 != connect(socketfd, (struct sockaddr *)&sun, sizeof(sun)))
+    {
+        PLOGE("connect");
+        exit(-1);
+    }
+
+    ALOGV("connecting client %d", getpid());
+
+    // Determine which one of our streams are attached to a TTY
+    int atty = 0;
+
+    // TODO: Check a system property and never use PTYs if
+    // the property is set.
+    if (isatty(STDIN_FILENO))
+        atty |= ATTY_IN;
+    if (isatty(STDOUT_FILENO))
+        atty |= ATTY_OUT;
+    if (isatty(STDERR_FILENO))
+        atty |= ATTY_ERR;
+
+    if (atty)
+    {
+        // We need a PTY. Get one.
+        ptmx = pts_open(pts_slave, sizeof(pts_slave));
+        if (ptmx < 0)
+        {
+            PLOGE("pts_open");
+            exit(-1);
+        }
+    }
+    else
+    {
+        pts_slave[0] = '\0';
+    }
+
+    // Send some info to the daemon, starting with our PID
+    write_int(socketfd, getpid());
+    // Send the slave path to the daemon
+    // (This is "" if we're not using PTYs)
+    write_string(socketfd, pts_slave);
+    // Parent PID
+    write_int(socketfd, ppid);
+
+    // Send stdin
+    if (atty & ATTY_IN)
+    {
+        // Using PTY
+        send_fd(socketfd, -1);
+    }
+    else
+    {
+        send_fd(socketfd, STDIN_FILENO);
+    }
+
+    // Send stdout
+    if (atty & ATTY_OUT)
+    {
+        // Forward SIGWINCH
+        watch_sigwinch_async(STDOUT_FILENO, ptmx);
+
+        // Using PTY
+        send_fd(socketfd, -1);
+    }
+    else
+    {
+        send_fd(socketfd, STDOUT_FILENO);
+    }
+
+    // Send stderr
+    if (atty & ATTY_ERR)
+    {
+        // Using PTY
+        send_fd(socketfd, -1);
+    }
+    else
+    {
+        send_fd(socketfd, STDERR_FILENO);
+    }
+
+    // Number of command line arguments
+    write_int(socketfd, argc);
+
+    // Command line arguments
+    int i;
+    for (i = 0; i < argc; i++)
+    {
+        write_string(socketfd, argv[i]);
+    }
+
+    // Wait for acknowledgement from daemon
+    read_int(socketfd);
+
+    if (atty & ATTY_IN)
+    {
+        setup_sighandlers();
+        pump_stdin_async(ptmx);
+    }
+    if (atty & ATTY_OUT)
+    {
+        pump_stdout_blocking(ptmx);
+    }
+
+    // Get the exit code
+    int code = read_int(socketfd);
+    close(socketfd);
+    ALOGD("client exited %d", code);
+
+    return code;
+}
diff --git a/su/pts.c b/su/pts.c
new file mode 100644
index 00000000..dcd7846c
--- /dev/null
+++ b/su/pts.c
@@ -0,0 +1,369 @@
+/*
+ * Copyright 2013, Tan Chee Eng (@tan-ce)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * pts.c
+ *
+ * Manages the pseudo-terminal driver on Linux/Android and provides some
+ * helper functions to handle raw input mode and terminal window resizing
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <string.h>
+#include <termios.h>
+#include <unistd.h>
+
+#include "pts.h"
+
+/**
+ * Helper functions
+ */
+// Ensures all the data is written out
+static int write_blocking(int fd, char *buf, size_t bufsz)
+{
+    ssize_t ret, written;
+
+    written = 0;
+    do
+    {
+        ret = write(fd, buf + written, bufsz - written);
+        if (ret == -1)
+            return -1;
+        written += ret;
+    } while (written < (ssize_t)bufsz);
+
+    return 0;
+}
+
+/**
+ * Pump data from input FD to output FD. If close_output is
+ * true, then close the output FD when we're done.
+ */
+static void pump_ex(int input, int output, int close_output)
+{
+    char buf[4096];
+    int len;
+    while ((len = read(input, buf, 4096)) > 0)
+    {
+        if (write_blocking(output, buf, len) == -1)
+            break;
+    }
+    close(input);
+    if (close_output)
+        close(output);
+}
+
+/**
+ * Pump data from input FD to output FD. Will close the
+ * output FD when done.
+ */
+static void pump(int input, int output)
+{
+    pump_ex(input, output, 1);
+}
+
+static void *pump_thread(void *data)
+{
+    int *files = (int *)data;
+    int input = files[0];
+    int output = files[1];
+    pump(input, output);
+    free(data);
+    return NULL;
+}
+
+static void pump_async(int input, int output)
+{
+    pthread_t writer;
+    int *files = (int *)malloc(sizeof(int) * 2);
+    if (files == NULL)
+    {
+        exit(-1);
+    }
+    files[0] = input;
+    files[1] = output;
+    pthread_create(&writer, NULL, pump_thread, files);
+}
+
+/**
+ * pts_open
+ *
+ * Opens a pts device and returns the name of the slave tty device.
+ *
+ * Arguments
+ * slave_name       the name of the slave device
+ * slave_name_size  the size of the buffer passed via slave_name
+ *
+ * Return Values
+ * on failure either -2 or -1 (errno set) is returned.
+ * on success, the file descriptor of the master device is returned.
+ */
+int pts_open(char *slave_name, size_t slave_name_size)
+{
+    int fdm;
+    char sn_tmp[slave_name_size];
+
+    // Open master ptmx device
+    fdm = open("/dev/ptmx", O_RDWR);
+    if (fdm == -1)
+        return -1;
+
+    // Get the slave name
+    if (ptsname_r(fdm, sn_tmp, slave_name_size) != 0)
+    {
+        close(fdm);
+        return -2;
+    }
+
+    if (strlcpy(slave_name, sn_tmp, slave_name_size) >= slave_name_size)
+    {
+        return -1;
+    }
+
+    // Grant, then unlock
+    if (grantpt(fdm) == -1)
+    {
+        close(fdm);
+        return -1;
+    }
+    if (unlockpt(fdm) == -1)
+    {
+        close(fdm);
+        return -1;
+    }
+
+    return fdm;
+}
+
+// Stores the previous termios of stdin
+static struct termios old_stdin;
+static int stdin_is_raw = 0;
+
+/**
+ * set_stdin_raw
+ *
+ * Changes stdin to raw unbuffered mode, disables echo,
+ * auto carriage return, etc.
+ *
+ * Return Value
+ * on failure -1, and errno is set
+ * on success 0
+ */
+int set_stdin_raw(void)
+{
+    struct termios new_termios;
+
+    // Save the current stdin termios
+    if (tcgetattr(STDIN_FILENO, &old_stdin) < 0)
+    {
+        return -1;
+    }
+
+    // Start from the current settings
+    new_termios = old_stdin;
+
+    // Make the terminal like an SSH or telnet client
+    new_termios.c_iflag |= IGNPAR;
+    new_termios.c_iflag &= ~(ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXANY | IXOFF);
+    new_termios.c_lflag &= ~(ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHONL);
+    new_termios.c_oflag &= ~OPOST;
+    new_termios.c_cc[VMIN] = 1;
+    new_termios.c_cc[VTIME] = 0;
+
+    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &new_termios) < 0)
+    {
+        return -1;
+    }
+
+    stdin_is_raw = 1;
+
+    return 0;
+}
+
+/**
+ * restore_stdin
+ *
+ * Restore termios on stdin to the state it was before
+ * set_stdin_raw() was called. If set_stdin_raw() was
+ * never called, does nothing and doesn't return an error.
+ *
+ * This function is async-safe.
+ *
+ * Return Value
+ * on failure, -1 and errno is set
+ * on success, 0
+ */
+int restore_stdin(void)
+{
+    if (!stdin_is_raw)
+        return 0;
+
+    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &old_stdin) < 0)
+    {
+        return -1;
+    }
+
+    stdin_is_raw = 0;
+
+    return 0;
+}
+
+// Flag indicating whether the sigwinch watcher should terminate.
+static volatile int closing_time = 0;
+
+/**
+ * Thread process. Wait for a SIGWINCH to be received, then update
+ * the terminal size.
+ */
+static void *watch_sigwinch(void *data)
+{
+    sigset_t winch;
+    int sig;
+    int master = ((int *)data)[0];
+    int slave = ((int *)data)[1];
+
+    sigemptyset(&winch);
+    sigaddset(&winch, SIGWINCH);
+
+    do
+    {
+        // Wait for a SIGWINCH
+        sigwait(&winch, &sig);
+
+        if (closing_time)
+            break;
+
+        // Get the new terminal size
+        struct winsize w;
+        if (ioctl(master, TIOCGWINSZ, &w) == -1)
+        {
+            continue;
+        }
+
+        // Set the new terminal size
+        ioctl(slave, TIOCSWINSZ, &w);
+
+    } while (1);
+
+    free(data);
+    return NULL;
+}
+
+/**
+ * watch_sigwinch_async
+ *
+ * After calling this function, if the application receives
+ * SIGWINCH, the terminal window size will be read from
+ * "input" and set on "output".
+ *
+ * NOTE: This function blocks SIGWINCH and spawns a thread.
+ * NOTE 2: This function must be called before any of the
+ *         pump functions.
+ *
+ * Arguments
+ * master   A file descriptor of the TTY window size to follow
+ * slave    A file descriptor of the TTY window size which is
+ *          to be set on SIGWINCH
+ *
+ * Return Value
+ * on failure, -1 and errno will be set. In this case, no
+ *      thread has been spawned and SIGWINCH will not be
+ *      blocked.
+ * on success, 0
+ */
+int watch_sigwinch_async(int master, int slave)
+{
+    pthread_t watcher;
+    int *files = (int *)malloc(sizeof(int) * 2);
+    if (files == NULL)
+    {
+        return -1;
+    }
+
+    // Block SIGWINCH so sigwait can later receive it
+    sigset_t winch;
+    sigemptyset(&winch);
+    sigaddset(&winch, SIGWINCH);
+    if (sigprocmask(SIG_BLOCK, &winch, NULL) == -1)
+    {
+        free(files);
+        return -1;
+    }
+
+    // Initialize some variables, then start the thread
+    closing_time = 0;
+    files[0] = master;
+    files[1] = slave;
+    int ret = pthread_create(&watcher, NULL, &watch_sigwinch, files);
+    if (ret != 0)
+    {
+        free(files);
+        errno = ret;
+        return -1;
+    }
+
+    // Set the initial terminal size
+    raise(SIGWINCH);
+    return 0;
+}
+
+/**
+ * watch_sigwinch_cleanup
+ *
+ * Cause the SIGWINCH watcher thread to terminate
+ */
+void watch_sigwinch_cleanup(void)
+{
+    closing_time = 1;
+    raise(SIGWINCH);
+}
+
+/**
+ * pump_stdin_async
+ *
+ * Forward data from STDIN to the given FD
+ * in a seperate thread
+ */
+void pump_stdin_async(int outfd)
+{
+    // Put stdin into raw mode
+    set_stdin_raw();
+
+    // Pump data from stdin to the PTY
+    pump_async(STDIN_FILENO, outfd);
+}
+
+/**
+ * pump_stdout_blocking
+ *
+ * Forward data from the FD to STDOUT.
+ * Returns when the remote end of the FD closes.
+ *
+ * Before returning, restores stdin settings.
+ */
+void pump_stdout_blocking(int infd)
+{
+    // Pump data from stdout to PTY
+    pump_ex(infd, STDOUT_FILENO, 0 /* Don't close output when done */);
+
+    // Cleanup
+    restore_stdin();
+    watch_sigwinch_cleanup();
+}
diff --git a/su/pts.h b/su/pts.h
new file mode 100644
index 00000000..241f6e2d
--- /dev/null
+++ b/su/pts.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2013, Tan Chee Eng (@tan-ce)
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * pts.h
+ *
+ * Manages the pseudo-terminal driver on Linux/Android and provides some
+ * helper functions to handle raw input mode and terminal window resizing
+ */
+
+#ifndef _PTS_H_
+#define _PTS_H_
+
+/**
+ * pts_open
+ *
+ * Opens a pts device and returns the name of the slave tty device.
+ *
+ * Arguments
+ * slave_name       the name of the slave device
+ * slave_name_size  the size of the buffer passed via slave_name
+ *
+ * Return Values
+ * on failure either -2 or -1 (errno set) is returned.
+ * on success, the file descriptor of the master device is returned.
+ */
+int pts_open(char *slave_name, size_t slave_name_size);
+
+/**
+ * set_stdin_raw
+ *
+ * Changes stdin to raw unbuffered mode, disables echo,
+ * auto carriage return, etc.
+ *
+ * Return Value
+ * on failure -1, and errno is set
+ * on success 0
+ */
+int set_stdin_raw(void);
+
+/**
+ * restore_stdin
+ *
+ * Restore termios on stdin to the state it was before
+ * set_stdin_raw() was called. If set_stdin_raw() was
+ * never called, does nothing and doesn't return an error.
+ *
+ * This function is async-safe.
+ *
+ * Return Value
+ * on failure, -1 and errno is set
+ * on success, 0
+ */
+int restore_stdin(void);
+
+/**
+ * watch_sigwinch_async
+ *
+ * After calling this function, if the application receives
+ * SIGWINCH, the terminal window size will be read from
+ * "input" and set on "output".
+ *
+ * NOTE: This function blocks SIGWINCH and spawns a thread.
+ *
+ * Arguments
+ * master   A file descriptor of the TTY window size to follow
+ * slave    A file descriptor of the TTY window size which is
+ *          to be set on SIGWINCH
+ *
+ * Return Value
+ * on failure, -1 and errno will be set. In this case, no
+ *      thread has been spawned and SIGWINCH will not be
+ *      blocked.
+ * on success, 0
+ */
+int watch_sigwinch_async(int master, int slave);
+
+/**
+ * watch_sigwinch_cleanup
+ *
+ * Cause the SIGWINCH watcher thread to terminate
+ */
+void watch_sigwinch_cleanup(void);
+
+/**
+ * pump_stdin_async
+ *
+ * Forward data from STDIN to the given FD
+ * in a seperate thread
+ */
+void pump_stdin_async(int outfd);
+
+/**
+ * pump_stdout_blocking
+ *
+ * Forward data from the FD to STDOUT.
+ * Returns when the remote end of the FD closes.
+ *
+ * Before returning, restores stdin settings.
+ */
+void pump_stdout_blocking(int infd);
+
+#endif
diff --git a/su/su.c b/su/su.c
new file mode 100644
index 00000000..88d5d821
--- /dev/null
+++ b/su/su.c
@@ -0,0 +1,592 @@
+/*
+** Copyright 2010, Adam Shanks (@ChainsDD)
+** Copyright 2008, Zinx Verituse (@zinxv)
+** Copyright 2017-2018, The LineageOS Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#include <getopt.h>
+#include <pwd.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <unistd.h>
+
+#include <cutils/android_filesystem_config.h>
+#include <cutils/properties.h>
+#include <log/log.h>
+
+#include "su.h"
+#include "utils.h"
+
+extern int is_daemon;
+extern int daemon_from_uid;
+extern int daemon_from_pid;
+
+char *resolve_package_name(int uid)
+{
+    char *package_name = NULL;
+    char *packages = read_file(PACKAGE_LIST_PATH);
+
+    if (packages == NULL)
+    {
+        return NULL;
+    }
+
+    char *p = packages;
+    while (*p)
+    {
+        char *line_end = strstr(p, "\n");
+        if (line_end == NULL)
+            break;
+
+        char *token;
+        char *pkgName = strtok_r(p, " ", &token);
+        if (pkgName != NULL)
+        {
+            char *pkgUid = strtok_r(NULL, " ", &token);
+            if (pkgUid != NULL)
+            {
+                char *endptr;
+                errno = 0;
+                int pkgUidInt = strtoul(pkgUid, &endptr, 10);
+                if ((errno == 0 && endptr != NULL && !(*endptr)) && pkgUidInt == uid)
+                {
+                    package_name = strdup(pkgName);
+                    break;
+                }
+            }
+        }
+        p = ++line_end;
+    }
+
+    free(packages);
+    return package_name;
+}
+
+int fork_zero_fucks()
+{
+    int pid = fork();
+    if (pid)
+    {
+        int status;
+        waitpid(pid, &status, 0);
+        return pid;
+    }
+    else
+    {
+        if ((pid = fork()))
+            exit(0);
+        return 0;
+    }
+}
+
+static int from_init(struct su_initiator *from)
+{
+    char path[PATH_MAX], exe[PATH_MAX];
+    char args[4096], *argv0, *argv_rest;
+    int fd;
+    ssize_t len;
+    int i;
+    int err;
+
+    from->uid = getuid();
+    from->pid = getppid();
+
+    if (is_daemon)
+    {
+        from->uid = daemon_from_uid;
+        from->pid = daemon_from_pid;
+    }
+
+    /* Get the command line */
+    snprintf(path, sizeof(path), "/proc/%d/cmdline", from->pid);
+    fd = open(path, O_RDONLY);
+    if (fd < 0)
+    {
+        PLOGE("Opening command line");
+        return -1;
+    }
+    len = read(fd, args, sizeof(args));
+    err = errno;
+    close(fd);
+    if (len < 0 || len == sizeof(args))
+    {
+        PLOGEV("Reading command line", err);
+        return -1;
+    }
+
+    argv0 = args;
+    argv_rest = NULL;
+    for (i = 0; i < len; i++)
+    {
+        if (args[i] == '\0')
+        {
+            if (!argv_rest)
+            {
+                argv_rest = &args[i + 1];
+            }
+            else
+            {
+                args[i] = ' ';
+            }
+        }
+    }
+    args[len] = '\0';
+
+    if (argv_rest)
+    {
+        if (strlcpy(from->args, argv_rest, sizeof(from->args)) >= sizeof(from->args))
+        {
+            ALOGE("argument too long");
+            return -1;
+        }
+    }
+    else
+    {
+        from->args[0] = '\0';
+    }
+
+    /* If this isn't app_process, use the real path instead of argv[0] */
+    snprintf(path, sizeof(path), "/proc/%d/exe", from->pid);
+    len = readlink(path, exe, sizeof(exe));
+    if (len < 0)
+    {
+        PLOGE("Getting exe path");
+        return -1;
+    }
+    exe[len] = '\0';
+    if (strcmp(exe, "/system/bin/app_process") != 0)
+    {
+        argv0 = exe;
+    }
+
+    if (strlcpy(from->bin, argv0, sizeof(from->bin)) >= sizeof(from->bin))
+    {
+        ALOGE("binary path too long");
+        return -1;
+    }
+
+    struct passwd *pw;
+    pw = getpwuid(from->uid);
+    if (pw && pw->pw_name)
+    {
+        if (strlcpy(from->name, pw->pw_name, sizeof(from->name)) >= sizeof(from->name))
+        {
+            ALOGE("name too long");
+            return -1;
+        }
+    }
+
+    return 0;
+}
+
+static void populate_environment(const struct su_context *ctx)
+{
+    struct passwd *pw;
+
+    if (ctx->to.keepenv)
+        return;
+
+    pw = getpwuid(ctx->to.uid);
+    if (pw)
+    {
+        setenv("HOME", pw->pw_dir, 1);
+        if (ctx->to.shell)
+            setenv("SHELL", ctx->to.shell, 1);
+        else
+            setenv("SHELL", DEFAULT_SHELL, 1);
+        if (ctx->to.login || ctx->to.uid)
+        {
+            setenv("USER", pw->pw_name, 1);
+            setenv("LOGNAME", pw->pw_name, 1);
+        }
+    }
+}
+
+void set_identity(unsigned int uid)
+{
+    /*
+     * Set effective uid back to root, otherwise setres[ug]id will fail
+     * if uid isn't root.
+     */
+    if (seteuid(0))
+    {
+        PLOGE("seteuid (root)");
+        exit(EXIT_FAILURE);
+    }
+    if (setresgid(uid, uid, uid))
+    {
+        PLOGE("setresgid (%u)", uid);
+        exit(EXIT_FAILURE);
+    }
+    if (setresuid(uid, uid, uid))
+    {
+        PLOGE("setresuid (%u)", uid);
+        exit(EXIT_FAILURE);
+    }
+}
+
+static void usage(int status)
+{
+    FILE *stream = (status == EXIT_SUCCESS) ? stdout : stderr;
+
+    fprintf(stream,
+            "Usage: su [options] [--] [-] [LOGIN] [--] [args...]\n\n"
+            "Options:\n"
+            "  --daemon                      start the su daemon agent\n"
+            "  -c, --command COMMAND         pass COMMAND to the invoked shell\n"
+            "  -h, --help                    display this help message and exit\n"
+            "  -, -l, --login                pretend the shell to be a login shell\n"
+            "  -m, -p,\n"
+            "  --preserve-environment        do not change environment variables\n"
+            "  -s, --shell SHELL             use SHELL instead of the default " DEFAULT_SHELL
+            "\n"
+            "  -v, --version                 display version number and exit\n"
+            "  -V                            display version code and exit,\n"
+            "                                this is used almost exclusively by Superuser.apk\n");
+    exit(status);
+}
+
+static __attribute__((noreturn)) void deny(struct su_context *ctx)
+{
+    char *cmd = get_command(&ctx->to);
+    ALOGW("request rejected (%u->%u %s)", ctx->from.uid, ctx->to.uid, cmd);
+    fprintf(stderr, "%s\n", strerror(EACCES));
+    exit(EXIT_FAILURE);
+}
+
+static __attribute__((noreturn)) void allow(struct su_context *ctx, const char *packageName)
+{
+    char *arg0;
+    int argc, err;
+
+    umask(ctx->umask);
+
+    char *binary;
+    argc = ctx->to.optind;
+    if (ctx->to.command)
+    {
+        binary = ctx->to.shell;
+        ctx->to.argv[--argc] = ctx->to.command;
+        ctx->to.argv[--argc] = "-c";
+    }
+    else if (ctx->to.shell)
+    {
+        binary = ctx->to.shell;
+    }
+    else
+    {
+        if (ctx->to.argv[argc])
+        {
+            binary = ctx->to.argv[argc++];
+        }
+        else
+        {
+            binary = DEFAULT_SHELL;
+        }
+    }
+
+    arg0 = strrchr(binary, '/');
+    arg0 = (arg0) ? arg0 + 1 : binary;
+    if (ctx->to.login)
+    {
+        int s = strlen(arg0) + 2;
+        char *p = malloc(s);
+
+        if (!p)
+            exit(EXIT_FAILURE);
+
+        *p = '-';
+        strcpy(p + 1, arg0);
+        arg0 = p;
+    }
+
+    populate_environment(ctx);
+    set_identity(ctx->to.uid);
+
+#define PARG(arg)                             \
+    (argc + (arg) < ctx->to.argc) ? " " : "", \
+        (argc + (arg) < ctx->to.argc) ? ctx->to.argv[argc + (arg)] : ""
+
+    ALOGD("%u %s executing %u %s using binary %s : %s%s%s%s%s%s%s%s%s%s%s%s%s%s", ctx->from.uid,
+          ctx->from.bin, ctx->to.uid, get_command(&ctx->to), binary, arg0, PARG(0), PARG(1),
+          PARG(2), PARG(3), PARG(4), PARG(5), (ctx->to.optind + 6 < ctx->to.argc) ? " ..." : "");
+
+    ctx->to.argv[--argc] = arg0;
+
+    int pid = fork();
+    if (!pid)
+    {
+        execvp(binary, ctx->to.argv + argc);
+        err = errno;
+        PLOGE("exec");
+        fprintf(stderr, "Cannot execute %s: %s\n", binary, strerror(err));
+        exit(EXIT_FAILURE);
+    }
+    else
+    {
+        int status, code;
+
+        ALOGD("Waiting for pid %d.", pid);
+        waitpid(pid, &status, 0);
+        ALOGD("pid %d returned %d.", pid, status);
+        code = WIFSIGNALED(status) ? WTERMSIG(status) + 128 : WEXITSTATUS(status);
+
+        if (packageName)
+        {
+            ALOGD("Finishing su operation for app [uid:%d, pkgName: %s]", ctx->from.uid, packageName);
+        }
+        exit(code);
+    }
+}
+
+int access_disabled(const struct su_initiator *from)
+{
+    char build_type[PROPERTY_VALUE_MAX];
+    int enabled;
+
+    /* Enforce persist.sys.root_access on non-eng builds for apps */
+    enabled = property_get_int32("persist.sys.root_access", 2);
+    property_get("ro.build.type", build_type, "");
+    if (strcmp("eng", build_type) != 0 && from->uid != AID_SHELL && from->uid != AID_ROOT &&
+        (enabled & LINEAGE_ROOT_ACCESS_APPS_ONLY) != LINEAGE_ROOT_ACCESS_APPS_ONLY)
+    {
+        ALOGE(
+            "Apps root access is disabled by system setting");
+        return 1;
+    }
+
+    return 0;
+}
+
+int main(int argc, char *argv[])
+{
+    if (getuid() != geteuid())
+    {
+        ALOGE("must not be a setuid binary");
+        return 1;
+    }
+
+    return su_main(argc, argv, 1);
+}
+
+int su_main(int argc, char *argv[], int need_client)
+{
+    // start up in daemon mode if prompted
+    if (argc == 2 && strcmp(argv[1], "--daemon") == 0)
+    {
+        return run_daemon();
+    }
+
+    int ppid = getppid();
+
+    // Sanitize all secure environment variables (from linker_environ.c in AOSP linker).
+    /* The same list than GLibc at this point */
+    static const char *const unsec_vars[] = {
+        "GCONV_PATH",
+        "GETCONF_DIR",
+        "HOSTALIASES",
+        "LD_AUDIT",
+        "LD_DEBUG",
+        "LD_DEBUG_OUTPUT",
+        "LD_DYNAMIC_WEAK",
+        "LD_LIBRARY_PATH",
+        "LD_ORIGIN_PATH",
+        "LD_PRELOAD",
+        "LD_PROFILE",
+        "LD_SHOW_AUXV",
+        "LD_USE_LOAD_BIAS",
+        "LOCALDOMAIN",
+        "LOCPATH",
+        "MALLOC_TRACE",
+        "MALLOC_CHECK_",
+        "NIS_PATH",
+        "NLSPATH",
+        "RESOLV_HOST_CONF",
+        "RES_OPTIONS",
+        "TMPDIR",
+        "TZDIR",
+        "LD_AOUT_LIBRARY_PATH",
+        "LD_AOUT_PRELOAD",
+        // not listed in linker, used due to system() call
+        "IFS",
+    };
+    const char *const *cp = unsec_vars;
+    const char *const *endp = cp + sizeof(unsec_vars) / sizeof(unsec_vars[0]);
+    while (cp < endp)
+    {
+        unsetenv(*cp);
+        cp++;
+    }
+
+    ALOGD("su invoked.");
+
+    struct su_context ctx = {
+        .from =
+            {
+                .pid = -1,
+                .uid = 0,
+                .bin = "",
+                .args = "",
+                .name = "",
+            },
+        .to =
+            {
+                .uid = AID_ROOT,
+                .login = 0,
+                .keepenv = 0,
+                .shell = NULL,
+                .command = NULL,
+                .argv = argv,
+                .argc = argc,
+                .optind = 0,
+                .name = "",
+            },
+    };
+    int c;
+    struct option long_opts[] = {
+        {"command", required_argument, NULL, 'c'},
+        {"help", no_argument, NULL, 'h'},
+        {"login", no_argument, NULL, 'l'},
+        {"preserve-environment", no_argument, NULL, 'p'},
+        {"shell", required_argument, NULL, 's'},
+        {"version", no_argument, NULL, 'v'},
+        {NULL, 0, NULL, 0},
+    };
+
+    while ((c = getopt_long(argc, argv, "+c:hlmps:Vv", long_opts, NULL)) != -1)
+    {
+        switch (c)
+        {
+        case 'c':
+            ctx.to.shell = DEFAULT_SHELL;
+            ctx.to.command = optarg;
+            break;
+        case 'h':
+            usage(EXIT_SUCCESS);
+            break;
+        case 'l':
+            ctx.to.login = 1;
+            break;
+        case 'm':
+        case 'p':
+            ctx.to.keepenv = 1;
+            break;
+        case 's':
+            ctx.to.shell = optarg;
+            break;
+        case 'V':
+            printf("%d\n", VERSION_CODE);
+            exit(EXIT_SUCCESS);
+        case 'v':
+            printf("%s\n", VERSION);
+            exit(EXIT_SUCCESS);
+        default:
+            /* Bionic getopt_long doesn't terminate its error output by newline */
+            fprintf(stderr, "\n");
+            usage(2);
+        }
+    }
+
+    if (need_client)
+    {
+        // attempt to connect to daemon...
+        ALOGD("starting daemon client %d %d", getuid(), geteuid());
+        return connect_daemon(argc, argv, ppid);
+    }
+
+    if (optind < argc && !strcmp(argv[optind], "-"))
+    {
+        ctx.to.login = 1;
+        optind++;
+    }
+    /* username or uid */
+    if (optind < argc && strcmp(argv[optind], "--") != 0)
+    {
+        struct passwd *pw;
+        pw = getpwnam(argv[optind]);
+        if (!pw)
+        {
+            char *endptr;
+
+            /* It seems we shouldn't do this at all */
+            errno = 0;
+            ctx.to.uid = strtoul(argv[optind], &endptr, 10);
+            if (errno || *endptr)
+            {
+                ALOGE("Unknown id: %s\n", argv[optind]);
+                fprintf(stderr, "Unknown id: %s\n", argv[optind]);
+                exit(EXIT_FAILURE);
+            }
+        }
+        else
+        {
+            ctx.to.uid = pw->pw_uid;
+            if (pw->pw_name)
+            {
+                if (strlcpy(ctx.to.name, pw->pw_name, sizeof(ctx.to.name)) >= sizeof(ctx.to.name))
+                {
+                    ALOGE("name too long");
+                    exit(EXIT_FAILURE);
+                }
+            }
+        }
+        optind++;
+    }
+    if (optind < argc && !strcmp(argv[optind], "--"))
+    {
+        optind++;
+    }
+    ctx.to.optind = optind;
+
+    if (from_init(&ctx.from) < 0)
+    {
+        deny(&ctx);
+    }
+
+    ALOGE("SU from: %s", ctx.from.name);
+
+    if (ctx.from.uid == AID_ROOT)
+    {
+        ALOGD("Allowing root.");
+        allow(&ctx, NULL);
+    }
+
+    // check if superuser is disabled completely
+    if (access_disabled(&ctx.from))
+    {
+        ALOGD("access_disabled");
+        deny(&ctx);
+    }
+
+    // autogrant shell at this point
+    if (ctx.from.uid == AID_SHELL)
+    {
+        ALOGD("Allowing shell.");
+        allow(&ctx, NULL);
+    }
+
+    char *packageName = resolve_package_name(ctx.from.uid);
+    if (packageName)
+    {
+        ALOGD("Allowing by default.");
+        allow(&ctx, packageName);
+        free(packageName);
+    }
+
+    ALOGE("Allow chain exhausted, denying request");
+    deny(&ctx);
+}
diff --git a/su/su.cpp b/su/su.cpp
deleted file mode 100644
index 1a1ab6bf..00000000
--- a/su/su.cpp
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright (C) 2008 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <errno.h>
-#include <error.h>
-#include <getopt.h>
-#include <paths.h>
-#include <pwd.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-
-#include <private/android_filesystem_config.h>
-
-void pwtoid(const char* tok, uid_t* uid, gid_t* gid) {
-    struct passwd* pw = getpwnam(tok);
-    if (pw) {
-        if (uid) *uid = pw->pw_uid;
-        if (gid) *gid = pw->pw_gid;
-    } else {
-        char* end;
-        errno = 0;
-        uid_t tmpid = strtoul(tok, &end, 10);
-        if (errno != 0 || end == tok) error(1, errno, "invalid uid/gid '%s'", tok);
-        if (uid) *uid = tmpid;
-        if (gid) *gid = tmpid;
-    }
-}
-
-void extract_uidgids(const char* uidgids, uid_t* uid, gid_t* gid, gid_t* gids, int* gids_count) {
-    char *clobberablegids;
-    char *nexttok;
-    char *tok;
-    int gids_found;
-
-    if (!uidgids || !*uidgids) {
-        *gid = *uid = 0;
-        *gids_count = 0;
-        return;
-    }
-
-    clobberablegids = strdup(uidgids);
-    strcpy(clobberablegids, uidgids);
-    nexttok = clobberablegids;
-    tok = strsep(&nexttok, ",");
-    pwtoid(tok, uid, gid);
-    tok = strsep(&nexttok, ",");
-    if (!tok) {
-        /* gid is already set above */
-        *gids_count = 0;
-        free(clobberablegids);
-        return;
-    }
-    pwtoid(tok, NULL, gid);
-    gids_found = 0;
-    while ((gids_found < *gids_count) && (tok = strsep(&nexttok, ","))) {
-        pwtoid(tok, NULL, gids);
-        gids_found++;
-        gids++;
-    }
-    if (nexttok && gids_found == *gids_count) {
-        fprintf(stderr, "too many group ids\n");
-    }
-    *gids_count = gids_found;
-    free(clobberablegids);
-}
-
-int main(int argc, char** argv) {
-    uid_t current_uid = getuid();
-    if (current_uid != AID_ROOT && current_uid != AID_SHELL) error(1, 0, "not allowed");
-
-    // Handle -h and --help.
-    ++argv;
-    if (*argv && (strcmp(*argv, "--help") == 0 || strcmp(*argv, "-h") == 0)) {
-        fprintf(stderr,
-                "usage: su [WHO [COMMAND...]]\n"
-                "\n"
-                "Switch to WHO (default 'root') and run the given COMMAND (default sh).\n"
-                "\n"
-                "WHO is a comma-separated list of user, group, and supplementary groups\n"
-                "in that order.\n"
-                "\n");
-        return 0;
-    }
-
-    // The default user is root.
-    uid_t uid = 0;
-    gid_t gid = 0;
-
-    // If there are any arguments, the first argument is the uid/gid/supplementary groups.
-    if (*argv) {
-        gid_t gids[10];
-        int gids_count = sizeof(gids)/sizeof(gids[0]);
-        extract_uidgids(*argv, &uid, &gid, gids, &gids_count);
-        if (gids_count) {
-            if (setgroups(gids_count, gids)) {
-                error(1, errno, "setgroups failed");
-            }
-        }
-        ++argv;
-    }
-
-    if (setgid(gid)) error(1, errno, "setgid failed");
-    if (setuid(uid)) error(1, errno, "setuid failed");
-
-    // Reset parts of the environment.
-    setenv("PATH", _PATH_DEFPATH, 1);
-    unsetenv("IFS");
-    struct passwd* pw = getpwuid(uid);
-    if (pw) {
-        setenv("LOGNAME", pw->pw_name, 1);
-        setenv("USER", pw->pw_name, 1);
-    } else {
-        unsetenv("LOGNAME");
-        unsetenv("USER");
-    }
-
-    // Set up the arguments for exec.
-    char* exec_args[argc + 1];  // Having too much space is fine.
-    size_t i = 0;
-    for (; *argv != NULL; ++i) {
-      exec_args[i] = *argv++;
-    }
-    // Default to the standard shell.
-    if (i == 0) exec_args[i++] = const_cast<char*>("/system/bin/sh");
-    exec_args[i] = NULL;
-
-    execvp(exec_args[0], exec_args);
-    error(1, errno, "failed to exec %s", exec_args[0]);
-}
diff --git a/su/su.h b/su/su.h
new file mode 100644
index 00000000..a977c824
--- /dev/null
+++ b/su/su.h
@@ -0,0 +1,121 @@
+/*
+** Copyright 2010, Adam Shanks (@ChainsDD)
+** Copyright 2008, Zinx Verituse (@zinxv)
+** Copyright 2017-2018, The LineageOS Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#ifndef SU_h
+#define SU_h 1
+
+#ifdef LOG_TAG
+#undef LOG_TAG
+#endif
+#define LOG_TAG "su"
+
+// Lineage-specific behavior
+#define LINEAGE_ROOT_ACCESS_DISABLED 0
+#define LINEAGE_ROOT_ACCESS_APPS_ONLY 1
+#define LINEAGE_ROOT_ACCESS_ADB_ONLY 2
+#define LINEAGE_ROOT_ACCESS_APPS_AND_ADB 3
+
+#define DAEMON_SOCKET_PATH "/dev/socket/su-daemon/"
+
+#define DEFAULT_SHELL "/system/bin/sh"
+
+#define xstr(a) str(a)
+#define str(a) #a
+
+#ifndef VERSION_CODE
+#define VERSION_CODE 16
+#endif
+#define VERSION xstr(VERSION_CODE) " cm-su"
+
+#define PROTO_VERSION 1
+
+#define PACKAGE_LIST_PATH "/data/system/packages.list"
+#define PACKAGE_NAME_MAX_LEN (1 << 16)
+
+struct su_initiator
+{
+    pid_t pid;
+    unsigned uid;
+    unsigned user;
+    char name[64];
+    char bin[PATH_MAX];
+    char args[4096];
+};
+
+struct su_request
+{
+    unsigned uid;
+    char name[64];
+    int login;
+    int keepenv;
+    char *shell;
+    char *command;
+    char **argv;
+    int argc;
+    int optind;
+};
+
+struct su_context
+{
+    struct su_initiator from;
+    struct su_request to;
+    mode_t umask;
+    char sock_path[PATH_MAX];
+};
+
+typedef enum
+{
+    INTERACTIVE = 0,
+    DENY = 1,
+    ALLOW = 2,
+} policy_t;
+
+char *resolve_package_name(int uid);
+
+extern void set_identity(unsigned int uid);
+
+static inline char *get_command(const struct su_request *to)
+{
+    if (to->command)
+        return to->command;
+    if (to->shell)
+        return to->shell;
+    char *ret = to->argv[to->optind];
+    if (ret)
+        return ret;
+    return DEFAULT_SHELL;
+}
+
+int run_daemon();
+int connect_daemon(int argc, char *argv[], int ppid);
+int su_main(int argc, char *argv[], int need_client);
+// for when you give zero fucks about the state of the child process.
+// this version of fork understands you don't care about the child.
+// deadbeat dad fork.
+int fork_zero_fucks();
+
+#ifndef LOG_NDEBUG
+#define LOG_NDEBUG 1
+#endif
+
+#include <errno.h>
+#include <string.h>
+#define PLOGE(fmt, args...) ALOGE(fmt " failed with %d: %s", ##args, errno, strerror(errno))
+#define PLOGEV(fmt, err, args...) ALOGE(fmt " failed with %d: %s", ##args, err, strerror(err))
+
+#endif
diff --git a/su/superuser.rc b/su/superuser.rc
new file mode 100644
index 00000000..1d72d997
--- /dev/null
+++ b/su/superuser.rc
@@ -0,0 +1,12 @@
+# su daemon
+service su_daemon /system/xbin/su --daemon
+    user root
+    group root
+    disabled
+
+on property:persist.sys.root_access=0
+    stop su_daemon
+
+on property:persist.sys.root_access=1
+    exec /system/bin/setenforce 0
+    start su_daemon
diff --git a/su/utils.c b/su/utils.c
new file mode 100644
index 00000000..c6e41ece
--- /dev/null
+++ b/su/utils.c
@@ -0,0 +1,53 @@
+/*
+** Copyright 2012, The CyanogenMod Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#include <fcntl.h>
+#include <stdlib.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include "utils.h"
+
+/* reads a file, making sure it is terminated with \n \0 */
+char *read_file(const char *fn)
+{
+    struct stat st;
+    char *data = NULL;
+
+    int fd = open(fn, O_RDONLY);
+    if (fd < 0)
+        return data;
+
+    if (fstat(fd, &st))
+        goto oops;
+
+    data = malloc(st.st_size + 2);
+    if (!data)
+        goto oops;
+
+    if (read(fd, data, st.st_size) != st.st_size)
+        goto oops;
+    close(fd);
+    data[st.st_size] = '\n';
+    data[st.st_size + 1] = 0;
+    return data;
+
+oops:
+    close(fd);
+    if (data)
+        free(data);
+    return NULL;
+}
diff --git a/su/utils.h b/su/utils.h
new file mode 100644
index 00000000..f6f5a227
--- /dev/null
+++ b/su/utils.h
@@ -0,0 +1,23 @@
+/*
+** Copyright 2012, The CyanogenMod Project
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**     http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+*/
+
+#ifndef _UTILS_H_
+#define _UTILS_H_
+
+/* reads a file, making sure it is terminated with \n \0 */
+extern char *read_file(const char *fn);
+
+#endif
--
2.27.0
